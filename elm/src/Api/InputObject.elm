-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (..)

import Api.Enum.Agenda_constraint
import Api.Enum.Agenda_update_column
import Api.Enum.Consultation_constraint
import Api.Enum.Consultation_update_column
import Api.Enum.Order_by
import Api.Enum.Patient_Profession_constraint
import Api.Enum.Patient_Profession_update_column
import Api.Enum.Patient_constraint
import Api.Enum.Patient_update_column
import Api.Enum.Profession_constraint
import Api.Enum.Profession_update_column
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAgenda_arr_rel_insert_input : Agenda_arr_rel_insert_inputRequiredFields -> (Agenda_arr_rel_insert_inputOptionalFields -> Agenda_arr_rel_insert_inputOptionalFields) -> Agenda_arr_rel_insert_input
buildAgenda_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Agenda_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Agenda_arr_rel_insert_inputRequiredFields =
    { data : List Agenda_insert_input }


type alias Agenda_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Agenda_on_conflict }


{-| Type alias for the `Agenda_arr_rel_insert_input` attributes. Note that this type
needs to use the `Agenda_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agenda_arr_rel_insert_inputRaw =
    { data : List Agenda_insert_input
    , on_conflict : OptionalArgument Agenda_on_conflict
    }


{-| Type for the Agenda\_arr\_rel\_insert\_input input object.
-}
type Agenda_arr_rel_insert_input
    = Agenda_arr_rel_insert_input Agenda_arr_rel_insert_inputRaw


{-| Encode a Agenda\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAgenda_arr_rel_insert_input : Agenda_arr_rel_insert_input -> Value
encodeAgenda_arr_rel_insert_input (Agenda_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeAgenda_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeAgenda_on_conflict |> Encode.optional input.on_conflict ) ]


buildAgenda_bool_exp : (Agenda_bool_expOptionalFields -> Agenda_bool_expOptionalFields) -> Agenda_bool_exp
buildAgenda_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { consultations = Absent, and_ = Absent, not_ = Absent, or_ = Absent, date = Absent, heure = Absent, id_agenda = Absent }
    in
    Agenda_bool_exp { consultations = optionals.consultations, and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, date = optionals.date, heure = optionals.heure, id_agenda = optionals.id_agenda }


type alias Agenda_bool_expOptionalFields =
    { consultations : OptionalArgument Consultation_bool_exp
    , and_ : OptionalArgument (List (Maybe Agenda_bool_exp))
    , not_ : OptionalArgument Agenda_bool_exp
    , or_ : OptionalArgument (List (Maybe Agenda_bool_exp))
    , date : OptionalArgument Date_comparison_exp
    , heure : OptionalArgument Timetz_comparison_exp
    , id_agenda : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Agenda_bool_exp` attributes. Note that this type
needs to use the `Agenda_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agenda_bool_expRaw =
    { consultations : OptionalArgument Consultation_bool_exp
    , and_ : OptionalArgument (List (Maybe Agenda_bool_exp))
    , not_ : OptionalArgument Agenda_bool_exp
    , or_ : OptionalArgument (List (Maybe Agenda_bool_exp))
    , date : OptionalArgument Date_comparison_exp
    , heure : OptionalArgument Timetz_comparison_exp
    , id_agenda : OptionalArgument Int_comparison_exp
    }


{-| Type for the Agenda\_bool\_exp input object.
-}
type Agenda_bool_exp
    = Agenda_bool_exp Agenda_bool_expRaw


{-| Encode a Agenda\_bool\_exp into a value that can be used as an argument.
-}
encodeAgenda_bool_exp : Agenda_bool_exp -> Value
encodeAgenda_bool_exp (Agenda_bool_exp input) =
    Encode.maybeObject
        [ ( "Consultations", encodeConsultation_bool_exp |> Encode.optional input.consultations ), ( "_and", (encodeAgenda_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeAgenda_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeAgenda_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "date", encodeDate_comparison_exp |> Encode.optional input.date ), ( "heure", encodeTimetz_comparison_exp |> Encode.optional input.heure ), ( "id_agenda", encodeInt_comparison_exp |> Encode.optional input.id_agenda ) ]


buildAgenda_inc_input : (Agenda_inc_inputOptionalFields -> Agenda_inc_inputOptionalFields) -> Agenda_inc_input
buildAgenda_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id_agenda = Absent }
    in
    { id_agenda = optionals.id_agenda }


type alias Agenda_inc_inputOptionalFields =
    { id_agenda : OptionalArgument Int }


{-| Type for the Agenda\_inc\_input input object.
-}
type alias Agenda_inc_input =
    { id_agenda : OptionalArgument Int }


{-| Encode a Agenda\_inc\_input into a value that can be used as an argument.
-}
encodeAgenda_inc_input : Agenda_inc_input -> Value
encodeAgenda_inc_input input =
    Encode.maybeObject
        [ ( "id_agenda", Encode.int |> Encode.optional input.id_agenda ) ]


buildAgenda_insert_input : (Agenda_insert_inputOptionalFields -> Agenda_insert_inputOptionalFields) -> Agenda_insert_input
buildAgenda_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { consultations = Absent, date = Absent, heure = Absent, id_agenda = Absent }
    in
    Agenda_insert_input { consultations = optionals.consultations, date = optionals.date, heure = optionals.heure, id_agenda = optionals.id_agenda }


type alias Agenda_insert_inputOptionalFields =
    { consultations : OptionalArgument Consultation_arr_rel_insert_input
    , date : OptionalArgument Api.ScalarCodecs.Date
    , heure : OptionalArgument Api.ScalarCodecs.Timetz
    , id_agenda : OptionalArgument Int
    }


{-| Type alias for the `Agenda_insert_input` attributes. Note that this type
needs to use the `Agenda_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agenda_insert_inputRaw =
    { consultations : OptionalArgument Consultation_arr_rel_insert_input
    , date : OptionalArgument Api.ScalarCodecs.Date
    , heure : OptionalArgument Api.ScalarCodecs.Timetz
    , id_agenda : OptionalArgument Int
    }


{-| Type for the Agenda\_insert\_input input object.
-}
type Agenda_insert_input
    = Agenda_insert_input Agenda_insert_inputRaw


{-| Encode a Agenda\_insert\_input into a value that can be used as an argument.
-}
encodeAgenda_insert_input : Agenda_insert_input -> Value
encodeAgenda_insert_input (Agenda_insert_input input) =
    Encode.maybeObject
        [ ( "Consultations", encodeConsultation_arr_rel_insert_input |> Encode.optional input.consultations ), ( "date", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date ), ( "heure", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.heure ), ( "id_agenda", Encode.int |> Encode.optional input.id_agenda ) ]


buildAgenda_obj_rel_insert_input : Agenda_obj_rel_insert_inputRequiredFields -> (Agenda_obj_rel_insert_inputOptionalFields -> Agenda_obj_rel_insert_inputOptionalFields) -> Agenda_obj_rel_insert_input
buildAgenda_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Agenda_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Agenda_obj_rel_insert_inputRequiredFields =
    { data : Agenda_insert_input }


type alias Agenda_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Agenda_on_conflict }


{-| Type alias for the `Agenda_obj_rel_insert_input` attributes. Note that this type
needs to use the `Agenda_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agenda_obj_rel_insert_inputRaw =
    { data : Agenda_insert_input
    , on_conflict : OptionalArgument Agenda_on_conflict
    }


{-| Type for the Agenda\_obj\_rel\_insert\_input input object.
-}
type Agenda_obj_rel_insert_input
    = Agenda_obj_rel_insert_input Agenda_obj_rel_insert_inputRaw


{-| Encode a Agenda\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAgenda_obj_rel_insert_input : Agenda_obj_rel_insert_input -> Value
encodeAgenda_obj_rel_insert_input (Agenda_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeAgenda_insert_input input.data |> Just ), ( "on_conflict", encodeAgenda_on_conflict |> Encode.optional input.on_conflict ) ]


buildAgenda_on_conflict : Agenda_on_conflictRequiredFields -> (Agenda_on_conflictOptionalFields -> Agenda_on_conflictOptionalFields) -> Agenda_on_conflict
buildAgenda_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Agenda_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Agenda_on_conflictRequiredFields =
    { constraint : Api.Enum.Agenda_constraint.Agenda_constraint
    , update_columns : List Api.Enum.Agenda_update_column.Agenda_update_column
    }


type alias Agenda_on_conflictOptionalFields =
    { where_ : OptionalArgument Agenda_bool_exp }


{-| Type alias for the `Agenda_on_conflict` attributes. Note that this type
needs to use the `Agenda_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agenda_on_conflictRaw =
    { constraint : Api.Enum.Agenda_constraint.Agenda_constraint
    , update_columns : List Api.Enum.Agenda_update_column.Agenda_update_column
    , where_ : OptionalArgument Agenda_bool_exp
    }


{-| Type for the Agenda\_on\_conflict input object.
-}
type Agenda_on_conflict
    = Agenda_on_conflict Agenda_on_conflictRaw


{-| Encode a Agenda\_on\_conflict into a value that can be used as an argument.
-}
encodeAgenda_on_conflict : Agenda_on_conflict -> Value
encodeAgenda_on_conflict (Agenda_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Agenda_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Agenda_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeAgenda_bool_exp |> Encode.optional input.where_ ) ]


buildAgenda_order_by : (Agenda_order_byOptionalFields -> Agenda_order_byOptionalFields) -> Agenda_order_by
buildAgenda_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { date = Absent, heure = Absent, id_agenda = Absent }
    in
    { date = optionals.date, heure = optionals.heure, id_agenda = optionals.id_agenda }


type alias Agenda_order_byOptionalFields =
    { date : OptionalArgument Api.Enum.Order_by.Order_by
    , heure : OptionalArgument Api.Enum.Order_by.Order_by
    , id_agenda : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Agenda\_order\_by input object.
-}
type alias Agenda_order_by =
    { date : OptionalArgument Api.Enum.Order_by.Order_by
    , heure : OptionalArgument Api.Enum.Order_by.Order_by
    , id_agenda : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Agenda\_order\_by into a value that can be used as an argument.
-}
encodeAgenda_order_by : Agenda_order_by -> Value
encodeAgenda_order_by input =
    Encode.maybeObject
        [ ( "date", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date ), ( "heure", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.heure ), ( "id_agenda", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_agenda ) ]


buildAgenda_set_input : (Agenda_set_inputOptionalFields -> Agenda_set_inputOptionalFields) -> Agenda_set_input
buildAgenda_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { date = Absent, heure = Absent, id_agenda = Absent }
    in
    { date = optionals.date, heure = optionals.heure, id_agenda = optionals.id_agenda }


type alias Agenda_set_inputOptionalFields =
    { date : OptionalArgument Api.ScalarCodecs.Date
    , heure : OptionalArgument Api.ScalarCodecs.Timetz
    , id_agenda : OptionalArgument Int
    }


{-| Type for the Agenda\_set\_input input object.
-}
type alias Agenda_set_input =
    { date : OptionalArgument Api.ScalarCodecs.Date
    , heure : OptionalArgument Api.ScalarCodecs.Timetz
    , id_agenda : OptionalArgument Int
    }


{-| Encode a Agenda\_set\_input into a value that can be used as an argument.
-}
encodeAgenda_set_input : Agenda_set_input -> Value
encodeAgenda_set_input input =
    Encode.maybeObject
        [ ( "date", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date ), ( "heure", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.heure ), ( "id_agenda", Encode.int |> Encode.optional input.id_agenda ) ]


buildConsultation_arr_rel_insert_input : Consultation_arr_rel_insert_inputRequiredFields -> (Consultation_arr_rel_insert_inputOptionalFields -> Consultation_arr_rel_insert_inputOptionalFields) -> Consultation_arr_rel_insert_input
buildConsultation_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Consultation_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Consultation_arr_rel_insert_inputRequiredFields =
    { data : List Consultation_insert_input }


type alias Consultation_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Consultation_on_conflict }


{-| Type alias for the `Consultation_arr_rel_insert_input` attributes. Note that this type
needs to use the `Consultation_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Consultation_arr_rel_insert_inputRaw =
    { data : List Consultation_insert_input
    , on_conflict : OptionalArgument Consultation_on_conflict
    }


{-| Type for the Consultation\_arr\_rel\_insert\_input input object.
-}
type Consultation_arr_rel_insert_input
    = Consultation_arr_rel_insert_input Consultation_arr_rel_insert_inputRaw


{-| Encode a Consultation\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeConsultation_arr_rel_insert_input : Consultation_arr_rel_insert_input -> Value
encodeConsultation_arr_rel_insert_input (Consultation_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeConsultation_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeConsultation_on_conflict |> Encode.optional input.on_conflict ) ]


buildConsultation_bool_exp : (Consultation_bool_expOptionalFields -> Consultation_bool_expOptionalFields) -> Consultation_bool_exp
buildConsultation_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { agenda = Absent, patient = Absent, and_ = Absent, not_ = Absent, or_ = Absent, id_agenda = Absent, id_patient = Absent, indice_anxiete = Absent, mode_de_reglement = Absent, mots_cles = Absent, prix = Absent }
    in
    Consultation_bool_exp { agenda = optionals.agenda, patient = optionals.patient, and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id_agenda = optionals.id_agenda, id_patient = optionals.id_patient, indice_anxiete = optionals.indice_anxiete, mode_de_reglement = optionals.mode_de_reglement, mots_cles = optionals.mots_cles, prix = optionals.prix }


type alias Consultation_bool_expOptionalFields =
    { agenda : OptionalArgument Agenda_bool_exp
    , patient : OptionalArgument Patient_bool_exp
    , and_ : OptionalArgument (List (Maybe Consultation_bool_exp))
    , not_ : OptionalArgument Consultation_bool_exp
    , or_ : OptionalArgument (List (Maybe Consultation_bool_exp))
    , id_agenda : OptionalArgument Int_comparison_exp
    , id_patient : OptionalArgument Int_comparison_exp
    , indice_anxiete : OptionalArgument Smallint_comparison_exp
    , mode_de_reglement : OptionalArgument String_comparison_exp
    , mots_cles : OptionalArgument String_comparison_exp
    , prix : OptionalArgument Money_comparison_exp
    }


{-| Type alias for the `Consultation_bool_exp` attributes. Note that this type
needs to use the `Consultation_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Consultation_bool_expRaw =
    { agenda : OptionalArgument Agenda_bool_exp
    , patient : OptionalArgument Patient_bool_exp
    , and_ : OptionalArgument (List (Maybe Consultation_bool_exp))
    , not_ : OptionalArgument Consultation_bool_exp
    , or_ : OptionalArgument (List (Maybe Consultation_bool_exp))
    , id_agenda : OptionalArgument Int_comparison_exp
    , id_patient : OptionalArgument Int_comparison_exp
    , indice_anxiete : OptionalArgument Smallint_comparison_exp
    , mode_de_reglement : OptionalArgument String_comparison_exp
    , mots_cles : OptionalArgument String_comparison_exp
    , prix : OptionalArgument Money_comparison_exp
    }


{-| Type for the Consultation\_bool\_exp input object.
-}
type Consultation_bool_exp
    = Consultation_bool_exp Consultation_bool_expRaw


{-| Encode a Consultation\_bool\_exp into a value that can be used as an argument.
-}
encodeConsultation_bool_exp : Consultation_bool_exp -> Value
encodeConsultation_bool_exp (Consultation_bool_exp input) =
    Encode.maybeObject
        [ ( "Agenda", encodeAgenda_bool_exp |> Encode.optional input.agenda ), ( "Patient", encodePatient_bool_exp |> Encode.optional input.patient ), ( "_and", (encodeConsultation_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeConsultation_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeConsultation_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id_agenda", encodeInt_comparison_exp |> Encode.optional input.id_agenda ), ( "id_patient", encodeInt_comparison_exp |> Encode.optional input.id_patient ), ( "indice_anxiete", encodeSmallint_comparison_exp |> Encode.optional input.indice_anxiete ), ( "mode_de_reglement", encodeString_comparison_exp |> Encode.optional input.mode_de_reglement ), ( "mots_cles", encodeString_comparison_exp |> Encode.optional input.mots_cles ), ( "prix", encodeMoney_comparison_exp |> Encode.optional input.prix ) ]


buildConsultation_inc_input : (Consultation_inc_inputOptionalFields -> Consultation_inc_inputOptionalFields) -> Consultation_inc_input
buildConsultation_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id_agenda = Absent, id_patient = Absent, indice_anxiete = Absent }
    in
    { id_agenda = optionals.id_agenda, id_patient = optionals.id_patient, indice_anxiete = optionals.indice_anxiete }


type alias Consultation_inc_inputOptionalFields =
    { id_agenda : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , indice_anxiete : OptionalArgument Api.ScalarCodecs.Smallint
    }


{-| Type for the Consultation\_inc\_input input object.
-}
type alias Consultation_inc_input =
    { id_agenda : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , indice_anxiete : OptionalArgument Api.ScalarCodecs.Smallint
    }


{-| Encode a Consultation\_inc\_input into a value that can be used as an argument.
-}
encodeConsultation_inc_input : Consultation_inc_input -> Value
encodeConsultation_inc_input input =
    Encode.maybeObject
        [ ( "id_agenda", Encode.int |> Encode.optional input.id_agenda ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "indice_anxiete", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.indice_anxiete ) ]


buildConsultation_insert_input : (Consultation_insert_inputOptionalFields -> Consultation_insert_inputOptionalFields) -> Consultation_insert_input
buildConsultation_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { agenda = Absent, patient = Absent, id_agenda = Absent, id_patient = Absent, indice_anxiete = Absent, mode_de_reglement = Absent, mots_cles = Absent, prix = Absent }
    in
    Consultation_insert_input { agenda = optionals.agenda, patient = optionals.patient, id_agenda = optionals.id_agenda, id_patient = optionals.id_patient, indice_anxiete = optionals.indice_anxiete, mode_de_reglement = optionals.mode_de_reglement, mots_cles = optionals.mots_cles, prix = optionals.prix }


type alias Consultation_insert_inputOptionalFields =
    { agenda : OptionalArgument Agenda_obj_rel_insert_input
    , patient : OptionalArgument Patient_obj_rel_insert_input
    , id_agenda : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , indice_anxiete : OptionalArgument Api.ScalarCodecs.Smallint
    , mode_de_reglement : OptionalArgument String
    , mots_cles : OptionalArgument String
    , prix : OptionalArgument Api.ScalarCodecs.Money
    }


{-| Type alias for the `Consultation_insert_input` attributes. Note that this type
needs to use the `Consultation_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Consultation_insert_inputRaw =
    { agenda : OptionalArgument Agenda_obj_rel_insert_input
    , patient : OptionalArgument Patient_obj_rel_insert_input
    , id_agenda : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , indice_anxiete : OptionalArgument Api.ScalarCodecs.Smallint
    , mode_de_reglement : OptionalArgument String
    , mots_cles : OptionalArgument String
    , prix : OptionalArgument Api.ScalarCodecs.Money
    }


{-| Type for the Consultation\_insert\_input input object.
-}
type Consultation_insert_input
    = Consultation_insert_input Consultation_insert_inputRaw


{-| Encode a Consultation\_insert\_input into a value that can be used as an argument.
-}
encodeConsultation_insert_input : Consultation_insert_input -> Value
encodeConsultation_insert_input (Consultation_insert_input input) =
    Encode.maybeObject
        [ ( "Agenda", encodeAgenda_obj_rel_insert_input |> Encode.optional input.agenda ), ( "Patient", encodePatient_obj_rel_insert_input |> Encode.optional input.patient ), ( "id_agenda", Encode.int |> Encode.optional input.id_agenda ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "indice_anxiete", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.indice_anxiete ), ( "mode_de_reglement", Encode.string |> Encode.optional input.mode_de_reglement ), ( "mots_cles", Encode.string |> Encode.optional input.mots_cles ), ( "prix", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.prix ) ]


buildConsultation_obj_rel_insert_input : Consultation_obj_rel_insert_inputRequiredFields -> (Consultation_obj_rel_insert_inputOptionalFields -> Consultation_obj_rel_insert_inputOptionalFields) -> Consultation_obj_rel_insert_input
buildConsultation_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Consultation_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Consultation_obj_rel_insert_inputRequiredFields =
    { data : Consultation_insert_input }


type alias Consultation_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Consultation_on_conflict }


{-| Type alias for the `Consultation_obj_rel_insert_input` attributes. Note that this type
needs to use the `Consultation_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Consultation_obj_rel_insert_inputRaw =
    { data : Consultation_insert_input
    , on_conflict : OptionalArgument Consultation_on_conflict
    }


{-| Type for the Consultation\_obj\_rel\_insert\_input input object.
-}
type Consultation_obj_rel_insert_input
    = Consultation_obj_rel_insert_input Consultation_obj_rel_insert_inputRaw


{-| Encode a Consultation\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeConsultation_obj_rel_insert_input : Consultation_obj_rel_insert_input -> Value
encodeConsultation_obj_rel_insert_input (Consultation_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeConsultation_insert_input input.data |> Just ), ( "on_conflict", encodeConsultation_on_conflict |> Encode.optional input.on_conflict ) ]


buildConsultation_on_conflict : Consultation_on_conflictRequiredFields -> (Consultation_on_conflictOptionalFields -> Consultation_on_conflictOptionalFields) -> Consultation_on_conflict
buildConsultation_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Consultation_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Consultation_on_conflictRequiredFields =
    { constraint : Api.Enum.Consultation_constraint.Consultation_constraint
    , update_columns : List Api.Enum.Consultation_update_column.Consultation_update_column
    }


type alias Consultation_on_conflictOptionalFields =
    { where_ : OptionalArgument Consultation_bool_exp }


{-| Type alias for the `Consultation_on_conflict` attributes. Note that this type
needs to use the `Consultation_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Consultation_on_conflictRaw =
    { constraint : Api.Enum.Consultation_constraint.Consultation_constraint
    , update_columns : List Api.Enum.Consultation_update_column.Consultation_update_column
    , where_ : OptionalArgument Consultation_bool_exp
    }


{-| Type for the Consultation\_on\_conflict input object.
-}
type Consultation_on_conflict
    = Consultation_on_conflict Consultation_on_conflictRaw


{-| Encode a Consultation\_on\_conflict into a value that can be used as an argument.
-}
encodeConsultation_on_conflict : Consultation_on_conflict -> Value
encodeConsultation_on_conflict (Consultation_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Consultation_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Consultation_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeConsultation_bool_exp |> Encode.optional input.where_ ) ]


buildConsultation_order_by : (Consultation_order_byOptionalFields -> Consultation_order_byOptionalFields) -> Consultation_order_by
buildConsultation_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { agenda = Absent, patient = Absent, id_agenda = Absent, id_patient = Absent, indice_anxiete = Absent, mode_de_reglement = Absent, mots_cles = Absent, prix = Absent }
    in
    { agenda = optionals.agenda, patient = optionals.patient, id_agenda = optionals.id_agenda, id_patient = optionals.id_patient, indice_anxiete = optionals.indice_anxiete, mode_de_reglement = optionals.mode_de_reglement, mots_cles = optionals.mots_cles, prix = optionals.prix }


type alias Consultation_order_byOptionalFields =
    { agenda : OptionalArgument Agenda_order_by
    , patient : OptionalArgument Patient_order_by
    , id_agenda : OptionalArgument Api.Enum.Order_by.Order_by
    , id_patient : OptionalArgument Api.Enum.Order_by.Order_by
    , indice_anxiete : OptionalArgument Api.Enum.Order_by.Order_by
    , mode_de_reglement : OptionalArgument Api.Enum.Order_by.Order_by
    , mots_cles : OptionalArgument Api.Enum.Order_by.Order_by
    , prix : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Consultation\_order\_by input object.
-}
type alias Consultation_order_by =
    { agenda : OptionalArgument Agenda_order_by
    , patient : OptionalArgument Patient_order_by
    , id_agenda : OptionalArgument Api.Enum.Order_by.Order_by
    , id_patient : OptionalArgument Api.Enum.Order_by.Order_by
    , indice_anxiete : OptionalArgument Api.Enum.Order_by.Order_by
    , mode_de_reglement : OptionalArgument Api.Enum.Order_by.Order_by
    , mots_cles : OptionalArgument Api.Enum.Order_by.Order_by
    , prix : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Consultation\_order\_by into a value that can be used as an argument.
-}
encodeConsultation_order_by : Consultation_order_by -> Value
encodeConsultation_order_by input =
    Encode.maybeObject
        [ ( "Agenda", encodeAgenda_order_by |> Encode.optional input.agenda ), ( "Patient", encodePatient_order_by |> Encode.optional input.patient ), ( "id_agenda", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_agenda ), ( "id_patient", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_patient ), ( "indice_anxiete", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.indice_anxiete ), ( "mode_de_reglement", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.mode_de_reglement ), ( "mots_cles", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.mots_cles ), ( "prix", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.prix ) ]


buildConsultation_set_input : (Consultation_set_inputOptionalFields -> Consultation_set_inputOptionalFields) -> Consultation_set_input
buildConsultation_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id_agenda = Absent, id_patient = Absent, indice_anxiete = Absent, mode_de_reglement = Absent, mots_cles = Absent, prix = Absent }
    in
    { id_agenda = optionals.id_agenda, id_patient = optionals.id_patient, indice_anxiete = optionals.indice_anxiete, mode_de_reglement = optionals.mode_de_reglement, mots_cles = optionals.mots_cles, prix = optionals.prix }


type alias Consultation_set_inputOptionalFields =
    { id_agenda : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , indice_anxiete : OptionalArgument Api.ScalarCodecs.Smallint
    , mode_de_reglement : OptionalArgument String
    , mots_cles : OptionalArgument String
    , prix : OptionalArgument Api.ScalarCodecs.Money
    }


{-| Type for the Consultation\_set\_input input object.
-}
type alias Consultation_set_input =
    { id_agenda : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , indice_anxiete : OptionalArgument Api.ScalarCodecs.Smallint
    , mode_de_reglement : OptionalArgument String
    , mots_cles : OptionalArgument String
    , prix : OptionalArgument Api.ScalarCodecs.Money
    }


{-| Encode a Consultation\_set\_input into a value that can be used as an argument.
-}
encodeConsultation_set_input : Consultation_set_input -> Value
encodeConsultation_set_input input =
    Encode.maybeObject
        [ ( "id_agenda", Encode.int |> Encode.optional input.id_agenda ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "indice_anxiete", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.indice_anxiete ), ( "mode_de_reglement", Encode.string |> Encode.optional input.mode_de_reglement ), ( "mots_cles", Encode.string |> Encode.optional input.mots_cles ), ( "prix", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.prix ) ]


buildDate_comparison_exp : (Date_comparison_expOptionalFields -> Date_comparison_expOptionalFields) -> Date_comparison_exp
buildDate_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Date_comparison_expOptionalFields =
    { eq_ : OptionalArgument Api.ScalarCodecs.Date
    , gt_ : OptionalArgument Api.ScalarCodecs.Date
    , gte_ : OptionalArgument Api.ScalarCodecs.Date
    , in_ : OptionalArgument (List Api.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Date
    , lte_ : OptionalArgument Api.ScalarCodecs.Date
    , neq_ : OptionalArgument Api.ScalarCodecs.Date
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Date)
    }


{-| Type for the Date\_comparison\_exp input object.
-}
type alias Date_comparison_exp =
    { eq_ : OptionalArgument Api.ScalarCodecs.Date
    , gt_ : OptionalArgument Api.ScalarCodecs.Date
    , gte_ : OptionalArgument Api.ScalarCodecs.Date
    , in_ : OptionalArgument (List Api.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Date
    , lte_ : OptionalArgument Api.ScalarCodecs.Date
    , neq_ : OptionalArgument Api.ScalarCodecs.Date
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Date)
    }


{-| Encode a Date\_comparison\_exp into a value that can be used as an argument.
-}
encodeDate_comparison_exp : Date_comparison_exp -> Value
encodeDate_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.eq_ ), ( "_gt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.gt_ ), ( "_gte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.gte_ ), ( "_in", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.lt_ ), ( "_lte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.lte_ ), ( "_neq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.neq_ ), ( "_nin", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildInt_comparison_exp : (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields) -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildMoney_comparison_exp : (Money_comparison_expOptionalFields -> Money_comparison_expOptionalFields) -> Money_comparison_exp
buildMoney_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Money_comparison_expOptionalFields =
    { eq_ : OptionalArgument Api.ScalarCodecs.Money
    , gt_ : OptionalArgument Api.ScalarCodecs.Money
    , gte_ : OptionalArgument Api.ScalarCodecs.Money
    , in_ : OptionalArgument (List Api.ScalarCodecs.Money)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Money
    , lte_ : OptionalArgument Api.ScalarCodecs.Money
    , neq_ : OptionalArgument Api.ScalarCodecs.Money
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Money)
    }


{-| Type for the Money\_comparison\_exp input object.
-}
type alias Money_comparison_exp =
    { eq_ : OptionalArgument Api.ScalarCodecs.Money
    , gt_ : OptionalArgument Api.ScalarCodecs.Money
    , gte_ : OptionalArgument Api.ScalarCodecs.Money
    , in_ : OptionalArgument (List Api.ScalarCodecs.Money)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Money
    , lte_ : OptionalArgument Api.ScalarCodecs.Money
    , neq_ : OptionalArgument Api.ScalarCodecs.Money
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Money)
    }


{-| Encode a Money\_comparison\_exp into a value that can be used as an argument.
-}
encodeMoney_comparison_exp : Money_comparison_exp -> Value
encodeMoney_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.eq_ ), ( "_gt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.gt_ ), ( "_gte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.gte_ ), ( "_in", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.lt_ ), ( "_lte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.lte_ ), ( "_neq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.optional input.neq_ ), ( "_nin", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecMoney) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildPatient_Profession_arr_rel_insert_input : Patient_Profession_arr_rel_insert_inputRequiredFields -> (Patient_Profession_arr_rel_insert_inputOptionalFields -> Patient_Profession_arr_rel_insert_inputOptionalFields) -> Patient_Profession_arr_rel_insert_input
buildPatient_Profession_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Patient_Profession_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Patient_Profession_arr_rel_insert_inputRequiredFields =
    { data : List Patient_Profession_insert_input }


type alias Patient_Profession_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Patient_Profession_on_conflict }


{-| Type alias for the `Patient_Profession_arr_rel_insert_input` attributes. Note that this type
needs to use the `Patient_Profession_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_Profession_arr_rel_insert_inputRaw =
    { data : List Patient_Profession_insert_input
    , on_conflict : OptionalArgument Patient_Profession_on_conflict
    }


{-| Type for the Patient\_Profession\_arr\_rel\_insert\_input input object.
-}
type Patient_Profession_arr_rel_insert_input
    = Patient_Profession_arr_rel_insert_input Patient_Profession_arr_rel_insert_inputRaw


{-| Encode a Patient\_Profession\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePatient_Profession_arr_rel_insert_input : Patient_Profession_arr_rel_insert_input -> Value
encodePatient_Profession_arr_rel_insert_input (Patient_Profession_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePatient_Profession_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodePatient_Profession_on_conflict |> Encode.optional input.on_conflict ) ]


buildPatient_Profession_bool_exp : (Patient_Profession_bool_expOptionalFields -> Patient_Profession_bool_expOptionalFields) -> Patient_Profession_bool_exp
buildPatient_Profession_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { patient = Absent, profession = Absent, and_ = Absent, not_ = Absent, or_ = Absent, date_de_debut = Absent, date_de_fin = Absent, id_patient = Absent, id_profession = Absent }
    in
    Patient_Profession_bool_exp { patient = optionals.patient, profession = optionals.profession, and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, date_de_debut = optionals.date_de_debut, date_de_fin = optionals.date_de_fin, id_patient = optionals.id_patient, id_profession = optionals.id_profession }


type alias Patient_Profession_bool_expOptionalFields =
    { patient : OptionalArgument Patient_bool_exp
    , profession : OptionalArgument Profession_bool_exp
    , and_ : OptionalArgument (List (Maybe Patient_Profession_bool_exp))
    , not_ : OptionalArgument Patient_Profession_bool_exp
    , or_ : OptionalArgument (List (Maybe Patient_Profession_bool_exp))
    , date_de_debut : OptionalArgument Date_comparison_exp
    , date_de_fin : OptionalArgument Date_comparison_exp
    , id_patient : OptionalArgument Int_comparison_exp
    , id_profession : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Patient_Profession_bool_exp` attributes. Note that this type
needs to use the `Patient_Profession_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_Profession_bool_expRaw =
    { patient : OptionalArgument Patient_bool_exp
    , profession : OptionalArgument Profession_bool_exp
    , and_ : OptionalArgument (List (Maybe Patient_Profession_bool_exp))
    , not_ : OptionalArgument Patient_Profession_bool_exp
    , or_ : OptionalArgument (List (Maybe Patient_Profession_bool_exp))
    , date_de_debut : OptionalArgument Date_comparison_exp
    , date_de_fin : OptionalArgument Date_comparison_exp
    , id_patient : OptionalArgument Int_comparison_exp
    , id_profession : OptionalArgument Int_comparison_exp
    }


{-| Type for the Patient\_Profession\_bool\_exp input object.
-}
type Patient_Profession_bool_exp
    = Patient_Profession_bool_exp Patient_Profession_bool_expRaw


{-| Encode a Patient\_Profession\_bool\_exp into a value that can be used as an argument.
-}
encodePatient_Profession_bool_exp : Patient_Profession_bool_exp -> Value
encodePatient_Profession_bool_exp (Patient_Profession_bool_exp input) =
    Encode.maybeObject
        [ ( "Patient", encodePatient_bool_exp |> Encode.optional input.patient ), ( "Profession", encodeProfession_bool_exp |> Encode.optional input.profession ), ( "_and", (encodePatient_Profession_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePatient_Profession_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePatient_Profession_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "date_de_debut", encodeDate_comparison_exp |> Encode.optional input.date_de_debut ), ( "date_de_fin", encodeDate_comparison_exp |> Encode.optional input.date_de_fin ), ( "id_patient", encodeInt_comparison_exp |> Encode.optional input.id_patient ), ( "id_profession", encodeInt_comparison_exp |> Encode.optional input.id_profession ) ]


buildPatient_Profession_inc_input : (Patient_Profession_inc_inputOptionalFields -> Patient_Profession_inc_inputOptionalFields) -> Patient_Profession_inc_input
buildPatient_Profession_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id_patient = Absent, id_profession = Absent }
    in
    { id_patient = optionals.id_patient, id_profession = optionals.id_profession }


type alias Patient_Profession_inc_inputOptionalFields =
    { id_patient : OptionalArgument Int
    , id_profession : OptionalArgument Int
    }


{-| Type for the Patient\_Profession\_inc\_input input object.
-}
type alias Patient_Profession_inc_input =
    { id_patient : OptionalArgument Int
    , id_profession : OptionalArgument Int
    }


{-| Encode a Patient\_Profession\_inc\_input into a value that can be used as an argument.
-}
encodePatient_Profession_inc_input : Patient_Profession_inc_input -> Value
encodePatient_Profession_inc_input input =
    Encode.maybeObject
        [ ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "id_profession", Encode.int |> Encode.optional input.id_profession ) ]


buildPatient_Profession_insert_input : (Patient_Profession_insert_inputOptionalFields -> Patient_Profession_insert_inputOptionalFields) -> Patient_Profession_insert_input
buildPatient_Profession_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { patient = Absent, profession = Absent, date_de_debut = Absent, date_de_fin = Absent, id_patient = Absent, id_profession = Absent }
    in
    Patient_Profession_insert_input { patient = optionals.patient, profession = optionals.profession, date_de_debut = optionals.date_de_debut, date_de_fin = optionals.date_de_fin, id_patient = optionals.id_patient, id_profession = optionals.id_profession }


type alias Patient_Profession_insert_inputOptionalFields =
    { patient : OptionalArgument Patient_obj_rel_insert_input
    , profession : OptionalArgument Profession_obj_rel_insert_input
    , date_de_debut : OptionalArgument Api.ScalarCodecs.Date
    , date_de_fin : OptionalArgument Api.ScalarCodecs.Date
    , id_patient : OptionalArgument Int
    , id_profession : OptionalArgument Int
    }


{-| Type alias for the `Patient_Profession_insert_input` attributes. Note that this type
needs to use the `Patient_Profession_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_Profession_insert_inputRaw =
    { patient : OptionalArgument Patient_obj_rel_insert_input
    , profession : OptionalArgument Profession_obj_rel_insert_input
    , date_de_debut : OptionalArgument Api.ScalarCodecs.Date
    , date_de_fin : OptionalArgument Api.ScalarCodecs.Date
    , id_patient : OptionalArgument Int
    , id_profession : OptionalArgument Int
    }


{-| Type for the Patient\_Profession\_insert\_input input object.
-}
type Patient_Profession_insert_input
    = Patient_Profession_insert_input Patient_Profession_insert_inputRaw


{-| Encode a Patient\_Profession\_insert\_input into a value that can be used as an argument.
-}
encodePatient_Profession_insert_input : Patient_Profession_insert_input -> Value
encodePatient_Profession_insert_input (Patient_Profession_insert_input input) =
    Encode.maybeObject
        [ ( "Patient", encodePatient_obj_rel_insert_input |> Encode.optional input.patient ), ( "Profession", encodeProfession_obj_rel_insert_input |> Encode.optional input.profession ), ( "date_de_debut", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date_de_debut ), ( "date_de_fin", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date_de_fin ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "id_profession", Encode.int |> Encode.optional input.id_profession ) ]


buildPatient_Profession_obj_rel_insert_input : Patient_Profession_obj_rel_insert_inputRequiredFields -> (Patient_Profession_obj_rel_insert_inputOptionalFields -> Patient_Profession_obj_rel_insert_inputOptionalFields) -> Patient_Profession_obj_rel_insert_input
buildPatient_Profession_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Patient_Profession_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Patient_Profession_obj_rel_insert_inputRequiredFields =
    { data : Patient_Profession_insert_input }


type alias Patient_Profession_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Patient_Profession_on_conflict }


{-| Type alias for the `Patient_Profession_obj_rel_insert_input` attributes. Note that this type
needs to use the `Patient_Profession_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_Profession_obj_rel_insert_inputRaw =
    { data : Patient_Profession_insert_input
    , on_conflict : OptionalArgument Patient_Profession_on_conflict
    }


{-| Type for the Patient\_Profession\_obj\_rel\_insert\_input input object.
-}
type Patient_Profession_obj_rel_insert_input
    = Patient_Profession_obj_rel_insert_input Patient_Profession_obj_rel_insert_inputRaw


{-| Encode a Patient\_Profession\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePatient_Profession_obj_rel_insert_input : Patient_Profession_obj_rel_insert_input -> Value
encodePatient_Profession_obj_rel_insert_input (Patient_Profession_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePatient_Profession_insert_input input.data |> Just ), ( "on_conflict", encodePatient_Profession_on_conflict |> Encode.optional input.on_conflict ) ]


buildPatient_Profession_on_conflict : Patient_Profession_on_conflictRequiredFields -> (Patient_Profession_on_conflictOptionalFields -> Patient_Profession_on_conflictOptionalFields) -> Patient_Profession_on_conflict
buildPatient_Profession_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Patient_Profession_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Patient_Profession_on_conflictRequiredFields =
    { constraint : Api.Enum.Patient_Profession_constraint.Patient_Profession_constraint
    , update_columns : List Api.Enum.Patient_Profession_update_column.Patient_Profession_update_column
    }


type alias Patient_Profession_on_conflictOptionalFields =
    { where_ : OptionalArgument Patient_Profession_bool_exp }


{-| Type alias for the `Patient_Profession_on_conflict` attributes. Note that this type
needs to use the `Patient_Profession_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_Profession_on_conflictRaw =
    { constraint : Api.Enum.Patient_Profession_constraint.Patient_Profession_constraint
    , update_columns : List Api.Enum.Patient_Profession_update_column.Patient_Profession_update_column
    , where_ : OptionalArgument Patient_Profession_bool_exp
    }


{-| Type for the Patient\_Profession\_on\_conflict input object.
-}
type Patient_Profession_on_conflict
    = Patient_Profession_on_conflict Patient_Profession_on_conflictRaw


{-| Encode a Patient\_Profession\_on\_conflict into a value that can be used as an argument.
-}
encodePatient_Profession_on_conflict : Patient_Profession_on_conflict -> Value
encodePatient_Profession_on_conflict (Patient_Profession_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Patient_Profession_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Patient_Profession_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodePatient_Profession_bool_exp |> Encode.optional input.where_ ) ]


buildPatient_Profession_order_by : (Patient_Profession_order_byOptionalFields -> Patient_Profession_order_byOptionalFields) -> Patient_Profession_order_by
buildPatient_Profession_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { patient = Absent, profession = Absent, date_de_debut = Absent, date_de_fin = Absent, id_patient = Absent, id_profession = Absent }
    in
    { patient = optionals.patient, profession = optionals.profession, date_de_debut = optionals.date_de_debut, date_de_fin = optionals.date_de_fin, id_patient = optionals.id_patient, id_profession = optionals.id_profession }


type alias Patient_Profession_order_byOptionalFields =
    { patient : OptionalArgument Patient_order_by
    , profession : OptionalArgument Profession_order_by
    , date_de_debut : OptionalArgument Api.Enum.Order_by.Order_by
    , date_de_fin : OptionalArgument Api.Enum.Order_by.Order_by
    , id_patient : OptionalArgument Api.Enum.Order_by.Order_by
    , id_profession : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Patient\_Profession\_order\_by input object.
-}
type alias Patient_Profession_order_by =
    { patient : OptionalArgument Patient_order_by
    , profession : OptionalArgument Profession_order_by
    , date_de_debut : OptionalArgument Api.Enum.Order_by.Order_by
    , date_de_fin : OptionalArgument Api.Enum.Order_by.Order_by
    , id_patient : OptionalArgument Api.Enum.Order_by.Order_by
    , id_profession : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Patient\_Profession\_order\_by into a value that can be used as an argument.
-}
encodePatient_Profession_order_by : Patient_Profession_order_by -> Value
encodePatient_Profession_order_by input =
    Encode.maybeObject
        [ ( "Patient", encodePatient_order_by |> Encode.optional input.patient ), ( "Profession", encodeProfession_order_by |> Encode.optional input.profession ), ( "date_de_debut", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date_de_debut ), ( "date_de_fin", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date_de_fin ), ( "id_patient", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_patient ), ( "id_profession", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_profession ) ]


buildPatient_Profession_set_input : (Patient_Profession_set_inputOptionalFields -> Patient_Profession_set_inputOptionalFields) -> Patient_Profession_set_input
buildPatient_Profession_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { date_de_debut = Absent, date_de_fin = Absent, id_patient = Absent, id_profession = Absent }
    in
    { date_de_debut = optionals.date_de_debut, date_de_fin = optionals.date_de_fin, id_patient = optionals.id_patient, id_profession = optionals.id_profession }


type alias Patient_Profession_set_inputOptionalFields =
    { date_de_debut : OptionalArgument Api.ScalarCodecs.Date
    , date_de_fin : OptionalArgument Api.ScalarCodecs.Date
    , id_patient : OptionalArgument Int
    , id_profession : OptionalArgument Int
    }


{-| Type for the Patient\_Profession\_set\_input input object.
-}
type alias Patient_Profession_set_input =
    { date_de_debut : OptionalArgument Api.ScalarCodecs.Date
    , date_de_fin : OptionalArgument Api.ScalarCodecs.Date
    , id_patient : OptionalArgument Int
    , id_profession : OptionalArgument Int
    }


{-| Encode a Patient\_Profession\_set\_input into a value that can be used as an argument.
-}
encodePatient_Profession_set_input : Patient_Profession_set_input -> Value
encodePatient_Profession_set_input input =
    Encode.maybeObject
        [ ( "date_de_debut", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date_de_debut ), ( "date_de_fin", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date_de_fin ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "id_profession", Encode.int |> Encode.optional input.id_profession ) ]


buildPatient_arr_rel_insert_input : Patient_arr_rel_insert_inputRequiredFields -> (Patient_arr_rel_insert_inputOptionalFields -> Patient_arr_rel_insert_inputOptionalFields) -> Patient_arr_rel_insert_input
buildPatient_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Patient_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Patient_arr_rel_insert_inputRequiredFields =
    { data : List Patient_insert_input }


type alias Patient_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Patient_on_conflict }


{-| Type alias for the `Patient_arr_rel_insert_input` attributes. Note that this type
needs to use the `Patient_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_arr_rel_insert_inputRaw =
    { data : List Patient_insert_input
    , on_conflict : OptionalArgument Patient_on_conflict
    }


{-| Type for the Patient\_arr\_rel\_insert\_input input object.
-}
type Patient_arr_rel_insert_input
    = Patient_arr_rel_insert_input Patient_arr_rel_insert_inputRaw


{-| Encode a Patient\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePatient_arr_rel_insert_input : Patient_arr_rel_insert_input -> Value
encodePatient_arr_rel_insert_input (Patient_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePatient_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodePatient_on_conflict |> Encode.optional input.on_conflict ) ]


buildPatient_bool_exp : (Patient_bool_expOptionalFields -> Patient_bool_expOptionalFields) -> Patient_bool_exp
buildPatient_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { consultations = Absent, patient_Professions = Absent, and_ = Absent, not_ = Absent, or_ = Absent, code_postal = Absent, date_de_naissance = Absent, genre = Absent, id_patient = Absent, moyen_de_decouverte = Absent, nom = Absent, numero_rue = Absent, pays = Absent, prenom = Absent, rue = Absent, ville = Absent }
    in
    Patient_bool_exp { consultations = optionals.consultations, patient_Professions = optionals.patient_Professions, and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, code_postal = optionals.code_postal, date_de_naissance = optionals.date_de_naissance, genre = optionals.genre, id_patient = optionals.id_patient, moyen_de_decouverte = optionals.moyen_de_decouverte, nom = optionals.nom, numero_rue = optionals.numero_rue, pays = optionals.pays, prenom = optionals.prenom, rue = optionals.rue, ville = optionals.ville }


type alias Patient_bool_expOptionalFields =
    { consultations : OptionalArgument Consultation_bool_exp
    , patient_Professions : OptionalArgument Patient_Profession_bool_exp
    , and_ : OptionalArgument (List (Maybe Patient_bool_exp))
    , not_ : OptionalArgument Patient_bool_exp
    , or_ : OptionalArgument (List (Maybe Patient_bool_exp))
    , code_postal : OptionalArgument Int_comparison_exp
    , date_de_naissance : OptionalArgument Date_comparison_exp
    , genre : OptionalArgument String_comparison_exp
    , id_patient : OptionalArgument Int_comparison_exp
    , moyen_de_decouverte : OptionalArgument String_comparison_exp
    , nom : OptionalArgument String_comparison_exp
    , numero_rue : OptionalArgument Int_comparison_exp
    , pays : OptionalArgument String_comparison_exp
    , prenom : OptionalArgument String_comparison_exp
    , rue : OptionalArgument String_comparison_exp
    , ville : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Patient_bool_exp` attributes. Note that this type
needs to use the `Patient_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_bool_expRaw =
    { consultations : OptionalArgument Consultation_bool_exp
    , patient_Professions : OptionalArgument Patient_Profession_bool_exp
    , and_ : OptionalArgument (List (Maybe Patient_bool_exp))
    , not_ : OptionalArgument Patient_bool_exp
    , or_ : OptionalArgument (List (Maybe Patient_bool_exp))
    , code_postal : OptionalArgument Int_comparison_exp
    , date_de_naissance : OptionalArgument Date_comparison_exp
    , genre : OptionalArgument String_comparison_exp
    , id_patient : OptionalArgument Int_comparison_exp
    , moyen_de_decouverte : OptionalArgument String_comparison_exp
    , nom : OptionalArgument String_comparison_exp
    , numero_rue : OptionalArgument Int_comparison_exp
    , pays : OptionalArgument String_comparison_exp
    , prenom : OptionalArgument String_comparison_exp
    , rue : OptionalArgument String_comparison_exp
    , ville : OptionalArgument String_comparison_exp
    }


{-| Type for the Patient\_bool\_exp input object.
-}
type Patient_bool_exp
    = Patient_bool_exp Patient_bool_expRaw


{-| Encode a Patient\_bool\_exp into a value that can be used as an argument.
-}
encodePatient_bool_exp : Patient_bool_exp -> Value
encodePatient_bool_exp (Patient_bool_exp input) =
    Encode.maybeObject
        [ ( "Consultations", encodeConsultation_bool_exp |> Encode.optional input.consultations ), ( "Patient_Professions", encodePatient_Profession_bool_exp |> Encode.optional input.patient_Professions ), ( "_and", (encodePatient_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePatient_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePatient_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "code_postal", encodeInt_comparison_exp |> Encode.optional input.code_postal ), ( "date_de_naissance", encodeDate_comparison_exp |> Encode.optional input.date_de_naissance ), ( "genre", encodeString_comparison_exp |> Encode.optional input.genre ), ( "id_patient", encodeInt_comparison_exp |> Encode.optional input.id_patient ), ( "moyen_de_decouverte", encodeString_comparison_exp |> Encode.optional input.moyen_de_decouverte ), ( "nom", encodeString_comparison_exp |> Encode.optional input.nom ), ( "numero_rue", encodeInt_comparison_exp |> Encode.optional input.numero_rue ), ( "pays", encodeString_comparison_exp |> Encode.optional input.pays ), ( "prenom", encodeString_comparison_exp |> Encode.optional input.prenom ), ( "rue", encodeString_comparison_exp |> Encode.optional input.rue ), ( "ville", encodeString_comparison_exp |> Encode.optional input.ville ) ]


buildPatient_inc_input : (Patient_inc_inputOptionalFields -> Patient_inc_inputOptionalFields) -> Patient_inc_input
buildPatient_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { code_postal = Absent, id_patient = Absent, numero_rue = Absent }
    in
    { code_postal = optionals.code_postal, id_patient = optionals.id_patient, numero_rue = optionals.numero_rue }


type alias Patient_inc_inputOptionalFields =
    { code_postal : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , numero_rue : OptionalArgument Int
    }


{-| Type for the Patient\_inc\_input input object.
-}
type alias Patient_inc_input =
    { code_postal : OptionalArgument Int
    , id_patient : OptionalArgument Int
    , numero_rue : OptionalArgument Int
    }


{-| Encode a Patient\_inc\_input into a value that can be used as an argument.
-}
encodePatient_inc_input : Patient_inc_input -> Value
encodePatient_inc_input input =
    Encode.maybeObject
        [ ( "code_postal", Encode.int |> Encode.optional input.code_postal ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "numero_rue", Encode.int |> Encode.optional input.numero_rue ) ]


buildPatient_insert_input : (Patient_insert_inputOptionalFields -> Patient_insert_inputOptionalFields) -> Patient_insert_input
buildPatient_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { consultations = Absent, patient_Professions = Absent, code_postal = Absent, date_de_naissance = Absent, genre = Absent, id_patient = Absent, moyen_de_decouverte = Absent, nom = Absent, numero_rue = Absent, pays = Absent, prenom = Absent, rue = Absent, ville = Absent }
    in
    Patient_insert_input { consultations = optionals.consultations, patient_Professions = optionals.patient_Professions, code_postal = optionals.code_postal, date_de_naissance = optionals.date_de_naissance, genre = optionals.genre, id_patient = optionals.id_patient, moyen_de_decouverte = optionals.moyen_de_decouverte, nom = optionals.nom, numero_rue = optionals.numero_rue, pays = optionals.pays, prenom = optionals.prenom, rue = optionals.rue, ville = optionals.ville }


type alias Patient_insert_inputOptionalFields =
    { consultations : OptionalArgument Consultation_arr_rel_insert_input
    , patient_Professions : OptionalArgument Patient_Profession_arr_rel_insert_input
    , code_postal : OptionalArgument Int
    , date_de_naissance : OptionalArgument Api.ScalarCodecs.Date
    , genre : OptionalArgument String
    , id_patient : OptionalArgument Int
    , moyen_de_decouverte : OptionalArgument String
    , nom : OptionalArgument String
    , numero_rue : OptionalArgument Int
    , pays : OptionalArgument String
    , prenom : OptionalArgument String
    , rue : OptionalArgument String
    , ville : OptionalArgument String
    }


{-| Type alias for the `Patient_insert_input` attributes. Note that this type
needs to use the `Patient_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_insert_inputRaw =
    { consultations : OptionalArgument Consultation_arr_rel_insert_input
    , patient_Professions : OptionalArgument Patient_Profession_arr_rel_insert_input
    , code_postal : OptionalArgument Int
    , date_de_naissance : OptionalArgument Api.ScalarCodecs.Date
    , genre : OptionalArgument String
    , id_patient : OptionalArgument Int
    , moyen_de_decouverte : OptionalArgument String
    , nom : OptionalArgument String
    , numero_rue : OptionalArgument Int
    , pays : OptionalArgument String
    , prenom : OptionalArgument String
    , rue : OptionalArgument String
    , ville : OptionalArgument String
    }


{-| Type for the Patient\_insert\_input input object.
-}
type Patient_insert_input
    = Patient_insert_input Patient_insert_inputRaw


{-| Encode a Patient\_insert\_input into a value that can be used as an argument.
-}
encodePatient_insert_input : Patient_insert_input -> Value
encodePatient_insert_input (Patient_insert_input input) =
    Encode.maybeObject
        [ ( "Consultations", encodeConsultation_arr_rel_insert_input |> Encode.optional input.consultations ), ( "Patient_Professions", encodePatient_Profession_arr_rel_insert_input |> Encode.optional input.patient_Professions ), ( "code_postal", Encode.int |> Encode.optional input.code_postal ), ( "date_de_naissance", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date_de_naissance ), ( "genre", Encode.string |> Encode.optional input.genre ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "moyen_de_decouverte", Encode.string |> Encode.optional input.moyen_de_decouverte ), ( "nom", Encode.string |> Encode.optional input.nom ), ( "numero_rue", Encode.int |> Encode.optional input.numero_rue ), ( "pays", Encode.string |> Encode.optional input.pays ), ( "prenom", Encode.string |> Encode.optional input.prenom ), ( "rue", Encode.string |> Encode.optional input.rue ), ( "ville", Encode.string |> Encode.optional input.ville ) ]


buildPatient_obj_rel_insert_input : Patient_obj_rel_insert_inputRequiredFields -> (Patient_obj_rel_insert_inputOptionalFields -> Patient_obj_rel_insert_inputOptionalFields) -> Patient_obj_rel_insert_input
buildPatient_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Patient_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Patient_obj_rel_insert_inputRequiredFields =
    { data : Patient_insert_input }


type alias Patient_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Patient_on_conflict }


{-| Type alias for the `Patient_obj_rel_insert_input` attributes. Note that this type
needs to use the `Patient_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_obj_rel_insert_inputRaw =
    { data : Patient_insert_input
    , on_conflict : OptionalArgument Patient_on_conflict
    }


{-| Type for the Patient\_obj\_rel\_insert\_input input object.
-}
type Patient_obj_rel_insert_input
    = Patient_obj_rel_insert_input Patient_obj_rel_insert_inputRaw


{-| Encode a Patient\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePatient_obj_rel_insert_input : Patient_obj_rel_insert_input -> Value
encodePatient_obj_rel_insert_input (Patient_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePatient_insert_input input.data |> Just ), ( "on_conflict", encodePatient_on_conflict |> Encode.optional input.on_conflict ) ]


buildPatient_on_conflict : Patient_on_conflictRequiredFields -> (Patient_on_conflictOptionalFields -> Patient_on_conflictOptionalFields) -> Patient_on_conflict
buildPatient_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Patient_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Patient_on_conflictRequiredFields =
    { constraint : Api.Enum.Patient_constraint.Patient_constraint
    , update_columns : List Api.Enum.Patient_update_column.Patient_update_column
    }


type alias Patient_on_conflictOptionalFields =
    { where_ : OptionalArgument Patient_bool_exp }


{-| Type alias for the `Patient_on_conflict` attributes. Note that this type
needs to use the `Patient_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Patient_on_conflictRaw =
    { constraint : Api.Enum.Patient_constraint.Patient_constraint
    , update_columns : List Api.Enum.Patient_update_column.Patient_update_column
    , where_ : OptionalArgument Patient_bool_exp
    }


{-| Type for the Patient\_on\_conflict input object.
-}
type Patient_on_conflict
    = Patient_on_conflict Patient_on_conflictRaw


{-| Encode a Patient\_on\_conflict into a value that can be used as an argument.
-}
encodePatient_on_conflict : Patient_on_conflict -> Value
encodePatient_on_conflict (Patient_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Patient_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Patient_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodePatient_bool_exp |> Encode.optional input.where_ ) ]


buildPatient_order_by : (Patient_order_byOptionalFields -> Patient_order_byOptionalFields) -> Patient_order_by
buildPatient_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { code_postal = Absent, date_de_naissance = Absent, genre = Absent, id_patient = Absent, moyen_de_decouverte = Absent, nom = Absent, numero_rue = Absent, pays = Absent, prenom = Absent, rue = Absent, ville = Absent }
    in
    { code_postal = optionals.code_postal, date_de_naissance = optionals.date_de_naissance, genre = optionals.genre, id_patient = optionals.id_patient, moyen_de_decouverte = optionals.moyen_de_decouverte, nom = optionals.nom, numero_rue = optionals.numero_rue, pays = optionals.pays, prenom = optionals.prenom, rue = optionals.rue, ville = optionals.ville }


type alias Patient_order_byOptionalFields =
    { code_postal : OptionalArgument Api.Enum.Order_by.Order_by
    , date_de_naissance : OptionalArgument Api.Enum.Order_by.Order_by
    , genre : OptionalArgument Api.Enum.Order_by.Order_by
    , id_patient : OptionalArgument Api.Enum.Order_by.Order_by
    , moyen_de_decouverte : OptionalArgument Api.Enum.Order_by.Order_by
    , nom : OptionalArgument Api.Enum.Order_by.Order_by
    , numero_rue : OptionalArgument Api.Enum.Order_by.Order_by
    , pays : OptionalArgument Api.Enum.Order_by.Order_by
    , prenom : OptionalArgument Api.Enum.Order_by.Order_by
    , rue : OptionalArgument Api.Enum.Order_by.Order_by
    , ville : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Patient\_order\_by input object.
-}
type alias Patient_order_by =
    { code_postal : OptionalArgument Api.Enum.Order_by.Order_by
    , date_de_naissance : OptionalArgument Api.Enum.Order_by.Order_by
    , genre : OptionalArgument Api.Enum.Order_by.Order_by
    , id_patient : OptionalArgument Api.Enum.Order_by.Order_by
    , moyen_de_decouverte : OptionalArgument Api.Enum.Order_by.Order_by
    , nom : OptionalArgument Api.Enum.Order_by.Order_by
    , numero_rue : OptionalArgument Api.Enum.Order_by.Order_by
    , pays : OptionalArgument Api.Enum.Order_by.Order_by
    , prenom : OptionalArgument Api.Enum.Order_by.Order_by
    , rue : OptionalArgument Api.Enum.Order_by.Order_by
    , ville : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Patient\_order\_by into a value that can be used as an argument.
-}
encodePatient_order_by : Patient_order_by -> Value
encodePatient_order_by input =
    Encode.maybeObject
        [ ( "code_postal", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.code_postal ), ( "date_de_naissance", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date_de_naissance ), ( "genre", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.genre ), ( "id_patient", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_patient ), ( "moyen_de_decouverte", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.moyen_de_decouverte ), ( "nom", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.nom ), ( "numero_rue", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.numero_rue ), ( "pays", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.pays ), ( "prenom", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.prenom ), ( "rue", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.rue ), ( "ville", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.ville ) ]


buildPatient_set_input : (Patient_set_inputOptionalFields -> Patient_set_inputOptionalFields) -> Patient_set_input
buildPatient_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { code_postal = Absent, date_de_naissance = Absent, genre = Absent, id_patient = Absent, moyen_de_decouverte = Absent, nom = Absent, numero_rue = Absent, pays = Absent, prenom = Absent, rue = Absent, ville = Absent }
    in
    { code_postal = optionals.code_postal, date_de_naissance = optionals.date_de_naissance, genre = optionals.genre, id_patient = optionals.id_patient, moyen_de_decouverte = optionals.moyen_de_decouverte, nom = optionals.nom, numero_rue = optionals.numero_rue, pays = optionals.pays, prenom = optionals.prenom, rue = optionals.rue, ville = optionals.ville }


type alias Patient_set_inputOptionalFields =
    { code_postal : OptionalArgument Int
    , date_de_naissance : OptionalArgument Api.ScalarCodecs.Date
    , genre : OptionalArgument String
    , id_patient : OptionalArgument Int
    , moyen_de_decouverte : OptionalArgument String
    , nom : OptionalArgument String
    , numero_rue : OptionalArgument Int
    , pays : OptionalArgument String
    , prenom : OptionalArgument String
    , rue : OptionalArgument String
    , ville : OptionalArgument String
    }


{-| Type for the Patient\_set\_input input object.
-}
type alias Patient_set_input =
    { code_postal : OptionalArgument Int
    , date_de_naissance : OptionalArgument Api.ScalarCodecs.Date
    , genre : OptionalArgument String
    , id_patient : OptionalArgument Int
    , moyen_de_decouverte : OptionalArgument String
    , nom : OptionalArgument String
    , numero_rue : OptionalArgument Int
    , pays : OptionalArgument String
    , prenom : OptionalArgument String
    , rue : OptionalArgument String
    , ville : OptionalArgument String
    }


{-| Encode a Patient\_set\_input into a value that can be used as an argument.
-}
encodePatient_set_input : Patient_set_input -> Value
encodePatient_set_input input =
    Encode.maybeObject
        [ ( "code_postal", Encode.int |> Encode.optional input.code_postal ), ( "date_de_naissance", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date_de_naissance ), ( "genre", Encode.string |> Encode.optional input.genre ), ( "id_patient", Encode.int |> Encode.optional input.id_patient ), ( "moyen_de_decouverte", Encode.string |> Encode.optional input.moyen_de_decouverte ), ( "nom", Encode.string |> Encode.optional input.nom ), ( "numero_rue", Encode.int |> Encode.optional input.numero_rue ), ( "pays", Encode.string |> Encode.optional input.pays ), ( "prenom", Encode.string |> Encode.optional input.prenom ), ( "rue", Encode.string |> Encode.optional input.rue ), ( "ville", Encode.string |> Encode.optional input.ville ) ]


buildProfession_arr_rel_insert_input : Profession_arr_rel_insert_inputRequiredFields -> (Profession_arr_rel_insert_inputOptionalFields -> Profession_arr_rel_insert_inputOptionalFields) -> Profession_arr_rel_insert_input
buildProfession_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Profession_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Profession_arr_rel_insert_inputRequiredFields =
    { data : List Profession_insert_input }


type alias Profession_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Profession_on_conflict }


{-| Type alias for the `Profession_arr_rel_insert_input` attributes. Note that this type
needs to use the `Profession_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Profession_arr_rel_insert_inputRaw =
    { data : List Profession_insert_input
    , on_conflict : OptionalArgument Profession_on_conflict
    }


{-| Type for the Profession\_arr\_rel\_insert\_input input object.
-}
type Profession_arr_rel_insert_input
    = Profession_arr_rel_insert_input Profession_arr_rel_insert_inputRaw


{-| Encode a Profession\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeProfession_arr_rel_insert_input : Profession_arr_rel_insert_input -> Value
encodeProfession_arr_rel_insert_input (Profession_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeProfession_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeProfession_on_conflict |> Encode.optional input.on_conflict ) ]


buildProfession_bool_exp : (Profession_bool_expOptionalFields -> Profession_bool_expOptionalFields) -> Profession_bool_exp
buildProfession_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { patient_Professions = Absent, and_ = Absent, not_ = Absent, or_ = Absent, id_profession = Absent, profession = Absent }
    in
    Profession_bool_exp { patient_Professions = optionals.patient_Professions, and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id_profession = optionals.id_profession, profession = optionals.profession }


type alias Profession_bool_expOptionalFields =
    { patient_Professions : OptionalArgument Patient_Profession_bool_exp
    , and_ : OptionalArgument (List (Maybe Profession_bool_exp))
    , not_ : OptionalArgument Profession_bool_exp
    , or_ : OptionalArgument (List (Maybe Profession_bool_exp))
    , id_profession : OptionalArgument Int_comparison_exp
    , profession : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Profession_bool_exp` attributes. Note that this type
needs to use the `Profession_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Profession_bool_expRaw =
    { patient_Professions : OptionalArgument Patient_Profession_bool_exp
    , and_ : OptionalArgument (List (Maybe Profession_bool_exp))
    , not_ : OptionalArgument Profession_bool_exp
    , or_ : OptionalArgument (List (Maybe Profession_bool_exp))
    , id_profession : OptionalArgument Int_comparison_exp
    , profession : OptionalArgument String_comparison_exp
    }


{-| Type for the Profession\_bool\_exp input object.
-}
type Profession_bool_exp
    = Profession_bool_exp Profession_bool_expRaw


{-| Encode a Profession\_bool\_exp into a value that can be used as an argument.
-}
encodeProfession_bool_exp : Profession_bool_exp -> Value
encodeProfession_bool_exp (Profession_bool_exp input) =
    Encode.maybeObject
        [ ( "Patient_Professions", encodePatient_Profession_bool_exp |> Encode.optional input.patient_Professions ), ( "_and", (encodeProfession_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeProfession_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeProfession_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id_profession", encodeInt_comparison_exp |> Encode.optional input.id_profession ), ( "profession", encodeString_comparison_exp |> Encode.optional input.profession ) ]


buildProfession_inc_input : (Profession_inc_inputOptionalFields -> Profession_inc_inputOptionalFields) -> Profession_inc_input
buildProfession_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id_profession = Absent }
    in
    { id_profession = optionals.id_profession }


type alias Profession_inc_inputOptionalFields =
    { id_profession : OptionalArgument Int }


{-| Type for the Profession\_inc\_input input object.
-}
type alias Profession_inc_input =
    { id_profession : OptionalArgument Int }


{-| Encode a Profession\_inc\_input into a value that can be used as an argument.
-}
encodeProfession_inc_input : Profession_inc_input -> Value
encodeProfession_inc_input input =
    Encode.maybeObject
        [ ( "id_profession", Encode.int |> Encode.optional input.id_profession ) ]


buildProfession_insert_input : (Profession_insert_inputOptionalFields -> Profession_insert_inputOptionalFields) -> Profession_insert_input
buildProfession_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { patient_Professions = Absent, id_profession = Absent, profession = Absent }
    in
    Profession_insert_input { patient_Professions = optionals.patient_Professions, id_profession = optionals.id_profession, profession = optionals.profession }


type alias Profession_insert_inputOptionalFields =
    { patient_Professions : OptionalArgument Patient_Profession_arr_rel_insert_input
    , id_profession : OptionalArgument Int
    , profession : OptionalArgument String
    }


{-| Type alias for the `Profession_insert_input` attributes. Note that this type
needs to use the `Profession_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Profession_insert_inputRaw =
    { patient_Professions : OptionalArgument Patient_Profession_arr_rel_insert_input
    , id_profession : OptionalArgument Int
    , profession : OptionalArgument String
    }


{-| Type for the Profession\_insert\_input input object.
-}
type Profession_insert_input
    = Profession_insert_input Profession_insert_inputRaw


{-| Encode a Profession\_insert\_input into a value that can be used as an argument.
-}
encodeProfession_insert_input : Profession_insert_input -> Value
encodeProfession_insert_input (Profession_insert_input input) =
    Encode.maybeObject
        [ ( "Patient_Professions", encodePatient_Profession_arr_rel_insert_input |> Encode.optional input.patient_Professions ), ( "id_profession", Encode.int |> Encode.optional input.id_profession ), ( "profession", Encode.string |> Encode.optional input.profession ) ]


buildProfession_obj_rel_insert_input : Profession_obj_rel_insert_inputRequiredFields -> (Profession_obj_rel_insert_inputOptionalFields -> Profession_obj_rel_insert_inputOptionalFields) -> Profession_obj_rel_insert_input
buildProfession_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Profession_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Profession_obj_rel_insert_inputRequiredFields =
    { data : Profession_insert_input }


type alias Profession_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Profession_on_conflict }


{-| Type alias for the `Profession_obj_rel_insert_input` attributes. Note that this type
needs to use the `Profession_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Profession_obj_rel_insert_inputRaw =
    { data : Profession_insert_input
    , on_conflict : OptionalArgument Profession_on_conflict
    }


{-| Type for the Profession\_obj\_rel\_insert\_input input object.
-}
type Profession_obj_rel_insert_input
    = Profession_obj_rel_insert_input Profession_obj_rel_insert_inputRaw


{-| Encode a Profession\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeProfession_obj_rel_insert_input : Profession_obj_rel_insert_input -> Value
encodeProfession_obj_rel_insert_input (Profession_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeProfession_insert_input input.data |> Just ), ( "on_conflict", encodeProfession_on_conflict |> Encode.optional input.on_conflict ) ]


buildProfession_on_conflict : Profession_on_conflictRequiredFields -> (Profession_on_conflictOptionalFields -> Profession_on_conflictOptionalFields) -> Profession_on_conflict
buildProfession_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Profession_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Profession_on_conflictRequiredFields =
    { constraint : Api.Enum.Profession_constraint.Profession_constraint
    , update_columns : List Api.Enum.Profession_update_column.Profession_update_column
    }


type alias Profession_on_conflictOptionalFields =
    { where_ : OptionalArgument Profession_bool_exp }


{-| Type alias for the `Profession_on_conflict` attributes. Note that this type
needs to use the `Profession_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Profession_on_conflictRaw =
    { constraint : Api.Enum.Profession_constraint.Profession_constraint
    , update_columns : List Api.Enum.Profession_update_column.Profession_update_column
    , where_ : OptionalArgument Profession_bool_exp
    }


{-| Type for the Profession\_on\_conflict input object.
-}
type Profession_on_conflict
    = Profession_on_conflict Profession_on_conflictRaw


{-| Encode a Profession\_on\_conflict into a value that can be used as an argument.
-}
encodeProfession_on_conflict : Profession_on_conflict -> Value
encodeProfession_on_conflict (Profession_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Profession_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Profession_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeProfession_bool_exp |> Encode.optional input.where_ ) ]


buildProfession_order_by : (Profession_order_byOptionalFields -> Profession_order_byOptionalFields) -> Profession_order_by
buildProfession_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id_profession = Absent, profession = Absent }
    in
    { id_profession = optionals.id_profession, profession = optionals.profession }


type alias Profession_order_byOptionalFields =
    { id_profession : OptionalArgument Api.Enum.Order_by.Order_by
    , profession : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Profession\_order\_by input object.
-}
type alias Profession_order_by =
    { id_profession : OptionalArgument Api.Enum.Order_by.Order_by
    , profession : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Profession\_order\_by into a value that can be used as an argument.
-}
encodeProfession_order_by : Profession_order_by -> Value
encodeProfession_order_by input =
    Encode.maybeObject
        [ ( "id_profession", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id_profession ), ( "profession", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.profession ) ]


buildProfession_set_input : (Profession_set_inputOptionalFields -> Profession_set_inputOptionalFields) -> Profession_set_input
buildProfession_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id_profession = Absent, profession = Absent }
    in
    { id_profession = optionals.id_profession, profession = optionals.profession }


type alias Profession_set_inputOptionalFields =
    { id_profession : OptionalArgument Int
    , profession : OptionalArgument String
    }


{-| Type for the Profession\_set\_input input object.
-}
type alias Profession_set_input =
    { id_profession : OptionalArgument Int
    , profession : OptionalArgument String
    }


{-| Encode a Profession\_set\_input into a value that can be used as an argument.
-}
encodeProfession_set_input : Profession_set_input -> Value
encodeProfession_set_input input =
    Encode.maybeObject
        [ ( "id_profession", Encode.int |> Encode.optional input.id_profession ), ( "profession", Encode.string |> Encode.optional input.profession ) ]


buildSmallint_comparison_exp : (Smallint_comparison_expOptionalFields -> Smallint_comparison_expOptionalFields) -> Smallint_comparison_exp
buildSmallint_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Smallint_comparison_expOptionalFields =
    { eq_ : OptionalArgument Api.ScalarCodecs.Smallint
    , gt_ : OptionalArgument Api.ScalarCodecs.Smallint
    , gte_ : OptionalArgument Api.ScalarCodecs.Smallint
    , in_ : OptionalArgument (List Api.ScalarCodecs.Smallint)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Smallint
    , lte_ : OptionalArgument Api.ScalarCodecs.Smallint
    , neq_ : OptionalArgument Api.ScalarCodecs.Smallint
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Smallint)
    }


{-| Type for the Smallint\_comparison\_exp input object.
-}
type alias Smallint_comparison_exp =
    { eq_ : OptionalArgument Api.ScalarCodecs.Smallint
    , gt_ : OptionalArgument Api.ScalarCodecs.Smallint
    , gte_ : OptionalArgument Api.ScalarCodecs.Smallint
    , in_ : OptionalArgument (List Api.ScalarCodecs.Smallint)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Smallint
    , lte_ : OptionalArgument Api.ScalarCodecs.Smallint
    , neq_ : OptionalArgument Api.ScalarCodecs.Smallint
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Smallint)
    }


{-| Encode a Smallint\_comparison\_exp into a value that can be used as an argument.
-}
encodeSmallint_comparison_exp : Smallint_comparison_exp -> Value
encodeSmallint_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.eq_ ), ( "_gt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.gt_ ), ( "_gte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.gte_ ), ( "_in", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.lt_ ), ( "_lte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.lte_ ), ( "_neq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.optional input.neq_ ), ( "_nin", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecSmallint) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimetz_comparison_exp : (Timetz_comparison_expOptionalFields -> Timetz_comparison_expOptionalFields) -> Timetz_comparison_exp
buildTimetz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timetz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Api.ScalarCodecs.Timetz
    , gt_ : OptionalArgument Api.ScalarCodecs.Timetz
    , gte_ : OptionalArgument Api.ScalarCodecs.Timetz
    , in_ : OptionalArgument (List Api.ScalarCodecs.Timetz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Timetz
    , lte_ : OptionalArgument Api.ScalarCodecs.Timetz
    , neq_ : OptionalArgument Api.ScalarCodecs.Timetz
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Timetz)
    }


{-| Type for the Timetz\_comparison\_exp input object.
-}
type alias Timetz_comparison_exp =
    { eq_ : OptionalArgument Api.ScalarCodecs.Timetz
    , gt_ : OptionalArgument Api.ScalarCodecs.Timetz
    , gte_ : OptionalArgument Api.ScalarCodecs.Timetz
    , in_ : OptionalArgument (List Api.ScalarCodecs.Timetz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Timetz
    , lte_ : OptionalArgument Api.ScalarCodecs.Timetz
    , neq_ : OptionalArgument Api.ScalarCodecs.Timetz
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Timetz)
    }


{-| Encode a Timetz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimetz_comparison_exp : Timetz_comparison_exp -> Value
encodeTimetz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.eq_ ), ( "_gt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.gt_ ), ( "_gte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.gte_ ), ( "_in", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.lt_ ), ( "_lte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.lte_ ), ( "_neq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.optional input.neq_ ), ( "_nin", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecTimetz) |> Encode.list) |> Encode.optional input.nin_ ) ]
